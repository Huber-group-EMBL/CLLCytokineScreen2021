---
title: 'CLL PD and Cytokine response M only '
author: "Holly Giles"
date: "`r doc_date()`"
output:
  BiocStyle::html_document:
      toc: yes
      toc_depth: 3
      toc_float: yes
      code_folding: "hide" 
---

In this vignette I present the analysis and source code to analyse the relationship between cytokine response and CLL-PD.

## Set up
Load libraries
```{r loadLibraries, cache = FALSE, message = FALSE, warning = FALSE}


library(patchwork)
library(ggplot2)
library(glmnet)
library(tidyverse)
library(gtable)
library(grid)

```

## Define Aesthetics
```{r defineAesthetics2}

source("../../R/themes_colors.R")

```

## Load data
Raw
```{r loadData2}

#df: tibble containing all screening viability data
load( "../../data/df.RData")

#patMeta: tibble containing all patient genetic data
load( "../../data/patMeta.RData")

#CLL-PD: tibble containing Proliferative drive values  for patients in screen
load( "../../data/CLL_PD.Rdata")

```

Process data
```{r processData2}

# Subset data to Cytokine only treatments, no drugs 

df_full<-df

df <- dplyr::filter(df, Drug == "DMSO", Cytokine != "No Cytokine") %>% 
  dplyr::select( PatientID, drugC, Cytokine, DCK, Log) 

```


## Define additional functions
### Scale Feature Matrix
Here I define a function to scale the matrix, with MAD, and centre to the median row wise. This is necessary before feeding this matrix to the lasso function.      
I removed the upper and lower limits of the scaling function. For the purposes of visualisation (i.e. in the heatmap), this is useful to reduce the effects of outliers, but for the purposes of modelling this is unhelpful.      

```{r Scale viability matrix}
########### Scaling and Centering of Viability Matrix ################

# medianCenter_MadScale: 
#function to  scale with MAD, center to merdian
medianCenter_MadScale <- function(x) {
  s <- median(x)
  #s=0
  (x - s) / mad(x, center = s)
}

# scaleCytResp function:  to apply medianCenter_MadScale row wise to viability matrix
scaleCytResp  <- function(x) t(apply(x, 1, medianCenter_MadScale)) 

```

### Perform L1 regression on continuous response
*runGlm*: to run  multi-variant regression. This function takes a feature matrix `X` and a continuous response matrix `y`, to run lasso or ridge regularised regression. The function will run the `cv.glmnet` function for the chosen number of `repeats`,  applying cross-fold validation using chosen number of `folds`. 
```{r runGlm }
#select lasso or ridge 
runGlm <- function(X, y, method = "lasso", repeats=30, folds = 3) {
  
  #set up objects
  modelList <- list()
  lambdaList <- c()
  varExplain <- c()
  
  #set up a matrix for values of coefficients, with a row for each feature, and a column for each repeat
  coefMat <- matrix(NA, ncol(X), repeats)
  
  #make row names = cytokines
  rownames(coefMat) <- colnames(X)

  #set alpha according to selected method
  if (method == "lasso"){
    alpha = 1
  } else if (method == "ridge") {
    alpha = 0
  }
  
  #Run cv.glmnet for chosen number of repeats 
  for (i in seq(repeats)) {
    
    #if there are more than two features, fit a glm
    if (ncol(X) > 2) {
      
      res <- cv.glmnet(X,y, type.measure = "mse", family="gaussian", 
                       nfolds = folds, alpha = alpha, standardize = FALSE)
      
      #add lambda min from this repeat to the list of lambdas
      lambdaList <- c(lambdaList, res$lambda.min)
      
      #put the res object (with lambdas) into the list of models
      modelList[[i]] <- res
      
      #extract the coefficients for each feature, for lambda.min
      coefModel <- coef(res, s = "lambda.min")[-1] #remove intercept row
      
      #put these coefficients into  column of coefMatrix corresponding to the repeat
      coefMat[,i] <- coefModel
      
      #calculate variance explained
      y.pred <- predict(res, s = "lambda.min", newx = X)
      varExp <- cor(as.vector(y),as.vector(y.pred))^2
      varExplain[i] <- ifelse(is.na(varExp), 0, varExp) 
      
     
      
    } else {
      #if there are only two features, fit a linear model
      fitlm<-lm(y~., data.frame(X))
      varExp <- summary(fitlm)$r.squared
      varExplain <- c(varExplain, varExp)
      
    }

  }
  #gather all lists
  list(modelList = modelList, lambdaList = lambdaList, varExplain = varExplain, coefMat = coefMat)
}


```


*lassoPlot*: to generate predictor profiles using output of `runGlm` function. Accepts `lassoOut`, a list of objects generated by `runGlm`, `viabMatrix` a feature matrix containing viability data for cytokines, `PDMatrix`, a response matrix containing CLL PD values data for corresponding samples to those in `viabMatrix`, `freqCut`, the proportion of times a coefficient should be selected to be displayed in the plot, and `coefCut`, the minimum size of coefficients to display in the plot.  
```{r lassoPlot3}


lassoPlot <- function(lassoOut, viabMatrix, PDMatrix, freqCut = 1, coefCut = 0.01) {

    
    ###FOR THE BAR PLOT
    #extract coefMat for each stimulus
    barValue <- rowMeans(lassoOut$coefMat)
    #extract proportion of repeats for which each coefficient is significant
    freqValue <- rowMeans(abs(sign(lassoOut$coefMat)))
    #filter out coefficients that don't meet freqCut and coefCut thresholds
    barValue <- barValue[abs(barValue) >= coefCut & freqValue >= freqCut] 
    #arrange the bar values in numerical order
    barValue <- barValue[order(barValue)]
    #if there are no sig coefficients, don't plot
    if(length(barValue) == 0) {
      
      next
    }

    ###FOR THE HEATMAP AND SCATTER PLOT
    #get feature matrix and response matrix to plot
    allData <- viabMatrix
    PDValue <- PDMatrix
    
    #get feature matrix for sig coefficients only
    tabValue <- allData[, names(barValue),drop=FALSE]
    ord <- order(PDValue)
    PDValue <- PDValue[ord]
    tabValue <- tabValue[ord, ,drop=FALSE]
    sampleIDs <- rownames(tabValue)
    tabValue <- as_tibble(tabValue)
    tabValue$Sample <- sampleIDs
    
    
    
    matValue <- gather(tabValue, key = "Var",value = "Value", -Sample)
    
    
    #arrange order of heatmap
    matValue$Var <- factor(matValue$Var, levels = names(barValue))
    matValue$Sample <- factor(matValue$Sample, levels = names(PDValue))

   
     #plot the heatmap 
    
      p1 <- ggplot(matValue, aes(x=Sample, y=Var)) + 
            geom_tile(aes(fill=Value), color = "white") + #ghost white
            theme_bw()+
            scale_y_discrete(expand=c(0,0)) + 
            theme(axis.title.y = element_text( size=14),
                  axis.title.x = element_text( size=14),
                  axis.text.x=element_text(hjust=0, size=11),
                  axis.text.y=element_text(hjust=0.1, size=11),
                  axis.ticks=element_blank(),
                  panel.border=element_rect(colour="gainsboro"),  
                  plot.title=element_text(face="bold", size = 18, margin = margin(t = -5, b = 1)), 
                  panel.background=element_blank(),
                  panel.grid.major=element_blank(), 
                  panel.grid.minor=element_blank()) + 
            xlab("Viability z score") + 
            ylab("") +
            scale_fill_gradient2(low = palblues[1],high = palreds[8], mid = "white",guide="none")
            
        

         
    #Plot the bar plot on the left of the heatmap 
    barDF = data.frame(barValue, nm = factor(names(barValue),levels=names(barValue)))
    
    p2 <- ggplot(data=barDF, aes(x = nm, y = barValue)) + 
      geom_bar(stat = "identity", 
               fill = ifelse(barValue<0,
                           palblues[6], palreds[8]), 
               colour = "black", 
               size=0.3) + 
      scale_x_discrete(expand = c(0, 0.5)) + 
      scale_y_continuous(expand = c(0, 0)) + 
      coord_flip(ylim = c(-0.3, 0.35)) + #changed from min(barValue) and max(barValue)
      theme(panel.grid.major = element_blank(), 
            panel.background = element_blank(), 
            axis.ticks.y = element_blank(),
            panel.grid.minor = element_blank(), 
            axis.text=element_text(size = 11, angle = 45, hjust = 1, vjust = 1),
                axis.title = element_text(size = 14), 
            panel.border = element_blank()) +
      ylab("Size of predictor") + 
      geom_vline(xintercept = c(0.5), 
                 color = "black", 
                 size = 0.6)
    
    #Plot the scatter plot under the heatmap
    
    scatterDF = data.frame(X=factor(names(PDValue), 
                                    levels=names(PDValue)), 
                           Y=unlist(PDValue))
    
    p3 <- 
      ggplot(scatterDF, aes(x=X, y=Y)) + 
      geom_point(shape=21, 
                     fill="dimgrey", 
                     colour="#707372", #dark grey
                     size=1.2) + 
      theme_bw() +
      theme(panel.grid.minor=element_blank(), 
                panel.grid.major.x=element_blank(), 
                #axis.title.x=element_blank(), 
                axis.ticks.x=element_blank(), 
                axis.text.y=element_text(size=11), 
                axis.title.x=element_text(size=14), 
                panel.border=element_rect(colour="dimgrey", size=0.1),
                panel.background=element_rect(fill="white")) +
      xlab("CLL PD for each sample")
    
    
    #Assemble all the plots togehter

    # construct the gtable
    wdths = c(0.2, 1.5, 0.2, 1.3*ncol(matValue), 1.5, 0.2)
    hghts = c(0.2, 0.2, 0.0020*nrow(matValue), 0.3, 1, 0.2)
    gt = gtable(widths=unit(wdths, "in"), heights=unit(hghts, "in"))
    
    ## make grobs
    gg1 = ggplotGrob(p1)
    gg2 = ggplotGrob(p2)
    gg3 = ggplotGrob(p3)

    ## fill in the gtable
   
    #HEATMAP
    #5:1 = "PREDICTORS"
    gt = gtable_add_grob(gt, gtable_filter(gg1, "panel"), 3, 4) # add heatmap
    gt = gtable_add_grob(gt, gtable_filter(gg1, "panel"), 3, 4) #add legend
    gt = gtable_add_grob(gt, gtable_filter(gg1, "title"), 1, 4) #add title to plot
    gt = gtable_add_grob(gt, gtable_filter(gg1, "axis-l"), 3, 5) # variable names
    gt = gtable_add_grob(gt, gtable_filter(gg1, "xlab-b"), 2, 4) # axis title
    
    #BARPLOT
    gt = gtable_add_grob(gt, gtable_filter(gg2, "panel"), 3, 2) # add barplot
    gt = gtable_add_grob(gt, gtable_filter(gg2, "axis-b"), 4, 2) # y axis for barplot
    gt = gtable_add_grob(gt, gtable_filter(gg2, "xlab-b"), 2, 2) # y lab for barplot

    
    #SCATTER PLOT
    gt = gtable_add_grob(gt, gtable_filter(gg3, "panel"), 5, 4) # add scatterplot
    gt = gtable_add_grob(gt, gtable_filter(gg3, "xlab-b"), 6, 4) # x label for scatter plot
    gt = gtable_add_grob(gt, gtable_filter(gg3, "axis-l"), 5, 3) #  axis for scatter plot
    
   
  grid.draw(gt)
 
}


```

# Prepare data
## Feature matrix
```{r featureMatrix}

########### Viability matrix ################
#make viability matrix for cytokine treatments for patients
cyt_viab <- dplyr::select(df, 
                PatientID, 
                Log, 
                Cytokine) %>% spread(Cytokine, Log) %>% as.data.frame()

#make PatID the row names
rownames(cyt_viab) <- unlist(cyt_viab[,1]) # the first row will be the header
cyt_viab <- dplyr::select(cyt_viab,-PatientID) 

cyt_viab <- t(cyt_viab)

#run scaleCytResp on viability matrix
x <- scaleCytResp(cyt_viab)

viabMat <-t(x)

```

## Response matrix 
```{r responseMatrix, message=FALSE}

Mpat <- patMeta %>% filter(IGHV.status == "M") %>% select(PatientID)

PDmat <- 
  filter(CLL_PD, PatientID %in% Mpat$PatientID) %>%
  dplyr::select(PatientID, CLL_PD) %>% 
  #reshape data
  spread(key = PatientID, value = CLL_PD) %>% 
  data.frame() 
  


#get only viability values for aptients that have a PD
viabMat <- viabMat[colnames(PDmat),]




```


# Run logistic regression
## Run model
``` {r RunLasso, warning = FALSE}

PDmat <- t(PDmat)

#fit the model
cvglmfit <- runGlm(viabMat, PDmat, method = "lasso", repeats = 30, folds = 3)
    
#collect the results for each stimulus in one object
dataResult <- cvglmfit


```

Get predictor profiles for stimuli of interest
```{r plotLasso3, message = FALSE, warning = FALSE}


PDmat <- 
  dplyr::select(CLL_PD, PatientID, CLL_PD) %>% 
  #reshape data
  spread(key = PatientID, value = CLL_PD) %>% 
  data.frame() 
  

#make sample order same as in geneMatrix
PDmat <- PDmat[,rownames(viabMat)]

#get only viability values for aptients that have a PD
viabMat <- viabMat[colnames(PDmat),]


lassoPlot(dataResult, 
          viabMat, #use viab matrix for heatmap 
          PDmat, #use CLL_PD matrix for scatter plot
          freqCut = 0.75, #coefficients should be selected in <75% of bootstrapped model files
          coefCut = 0.00) #no minimum value for coefficients 



```




## Appendix
```{r appendix2}
Sys.info()
sessionInfo()
```

